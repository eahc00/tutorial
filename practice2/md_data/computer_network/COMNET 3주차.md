  
Q1. 스위치(l2 : MAC) vs. 라우터(l3 : IP)의 차이
	→ 싼거에 비싼 기능을 붙여서 사용. 요즘 같이 씀.
	스위치 : LAN 내부에서 연결(호스트들끼리 묶어준다고 생각하면 좋을 듯 : 예시 - 허브)
	라우터 : 스위치들끼리 연결
Q2. 라우터는 네트워크 계층 밖에 없는데 에러 디텍션을 어떻게?
	→ 여기서 에러 디텍션을 하는 게 아니다. 데이터 송/수신 부분(호스트)에서 송신 데이터와 수신 데이터가 같은지 확인. → 어떻게 확인?
데이터링크 : 받은 정보를 잘 전달하는 신뢰성을 보장
트랜스포트, 어플리케이션은 데이터를 쓰고 받는 것에만 필요
Q3. 헤더와 함께 전달되는 데이터는 암호화 된 데이터?
  
Q4. 네트워크 레이어를 지날 때 decapsulation하는 헤더와 다시 Encapsulation하는 헤더는 같은 거?
	→ 네트워크 계층의 헤더는 바뀌지 않고 포트(transport)계층의 헤더는 바뀔 수 있다.
Q5. transport에서 UDP 쓰면은 신뢰성 보장 어케하나요.
	→ 안한다.
  
네트워크 layer를 의미하는 건지 포괄적인 네트워크 자체에서 일어나는 에러를 컨트롤 하는건지.
	→ 포괄적인 네트워크 자체에서 일어나는 에러를 컨트롤  
뭘 컨트롤 하는 건지(무슨 에러 검출?)  
	→ 데이터가 다르다.. (같은지 확인하는 것.)  
그럼 어떻게 날 수 있는건지?  
UDP 는 신뢰성 보장 안되는 거 아님? 근데 왜 신뢰성 보장이 transport layer의 특징이라 써놨는지.  
	→ 안되는 거 맞음. TCP 기준으로 설명한 것.
  
checksum
TCP : 3 way handshaking
http3 : quic (UDP : DNS)
  
\[데이터]
\[tcp 헤더]\[데이터]
\[ip]\[tcp 헤더]\[데이터]
\[mac - L2]\[ip]\[tcp 헤더]\[데이터]

  
# Chapter2 : Networks Model
  
## Objective
- Protocol layering(프로토콜 계층화)
    - 프로토콜 계층화의 두 가지 법칙
        1. 각 레이어의 두 개의 반대되는 작업이 있어야 한다.
        2. 대응(상응)하는 레이어가 동일해야 한다.
- TCP/IP의 5(4) 계층
    - 5계층에서 패킷의 이름이 어떻게 지정되는지
    - 주소 지정 매커니즘
- OSI 모델
    - 구현 된 적 없음
    - TCP/IP와의 비교
    - OSI가 성공하지 못한 이유


## Protocol Layering
- 프로토콜은 송신자와 수신자, 그리고 중간 장치(매개 장치)가 **효과적으로 통신하기 위해 따라야 하는 규칙을 정의**한다.
- 통신이 단순할 때는 하나의 간단한 프로토콜만 필요하지만, 통신이 복잡할 때는 각 계층에 프로토콜이 필요하거나 프로토콜 레이어링이 필요하다.


### Scenarios
두 개의 시나리오를 생각해보자.
1. 단 하나의 계층에서만 일어나는 간단한 통신.
2. 세 개의 계층에서 일어나는 통신.
  
- 첫 번째 케이스 : One layer
    ![[Untitled 36.png|Untitled 36.png|500]]
    - 앤과 마리는 많은 공통의 생각을 가진 이웃이다.
    - Face to face, 같은 언어로 소통
    - 따라야 할 몇 가지 규칙
        - 만났을 때 인사한다.
        - 비슷한 수준의 어휘로 대화한다.
        - 상대방이 말할 때 말하지 않는다. : 두 사람 모두 이야기 할 기회를 가져야 한다.
        - 헤어질 때는 좋은 말을 주고 받는다.
    - 앤과 마리의 프로토콜(소통 규칙)은 강의실에서의 교수와 학생들과의 소통 프로토콜과 다르다.
        - 후자의 경우 대부분 독백 : 학생이 규칙에 따라 손을 들고 발언 허가를 받고 말하지 않는 한 교수가 거의 대부분 말하고, 과목에 대한 이야기로 국한 된다.
    


- 두 번째 케이스 : three layers
    ![[Untitled 1 21.png|Untitled 1 21.png|500]]
    - 앤이 이사를 가게 되어 마리와 아주 먼 도시로 이사 가게 됐다.
        - 두 사람은 아이디어를 계속 교환하고 싶어한다.
        - 우체국을 통해 우편으로 대화를 이어가기로 한다. 하지만 누군가가 편지를 가로챌 경우 다른 사람에게 자신들의 아이디어가 노출되는 것을 원하지 않는다.
        - 그들의 암호화/복호화 기술에 동의한다. 송신자는 편지는 암호화하고 수신자는 이를 복호화하여 편지 원본을 얻는다.
        - 이제 마리와 앤 사이 통신은 세 계층에서 일어난다고 할 수 있다.
        - 앤과 마리는 각 계층에서 작업을 수행할 수 있는 machine을 각각 세 대씩 가지고 있다.
    - 마리가 앤에게 첫 번째 편지를 보낸다고 하자.
        - 마리는 세 번째 계층에서 Plain text로 된 편지를 생성한 뒤 두 번째 계층으로 전달한다.
        - 두 번째 계층에서는 plain text를 가져와 암호화 한 뒤 암호 텍스트를 첫 번째 계층으로 전달한다.
        - 첫 번째 계층에서는 암호 텍스트를 가져와 봉투에 넣고 발신자와 수신자 주소를 추가한 후 우편으로 발송한다.
    - 앤의 입장에서
        - 첫 번째 계층에서 앤의 우편함에서 편지를 받으면 발신자 주소로 마리가 보낸 편지임을 인식한다. 봉투에서 암호문을 꺼내서 두 번째 계층으로 전달한다.
        - 두 번째 계층에서 메시지를 해독(복호화)하고 plain text를 생성하고 세 번째 계층으로 전달한다.
        - 세 번째 계층은 plain text를 받아 마리에게 전달.



### Protocol Layering
- 프로토콜 계층화는 복잡한 task를 몇몇의 더 작고 더 쉬운 task로 나누는 것을 가능하게 한다.
    - 예를 들어 마리와 앤이 기계가 수행하는 암호화/복호화가 비밀을 보호하기에 충분하지 않다고 판단하면 현재 상황에서는 두 번째 계층의 기계만을 변경하면 된다.
- 이것을 **modularity**라고 부른다.
    - 다른 것에 영향을 주지 않고 **수정사항이 있다면 하나의 모듈(레이어 : 계층)만 수정**하도록
    - 이 경우 **Modularity는 독립적인 계층을 의미**한다. 계층(모듈)은 입력과 출력이 있는 블랙박스로 정의할 수 있으며, 어떻게 입력이 출력이 되는 지에 대해서는 신경 쓰지 않아도 된다.
    - 두 머신이 동일한 입력에 대하여 동일한 출력을 제공하는 경우 서로를 대체할 수 있다.
        - 기능만 명확히 해주면 다른 회사의 제품도 상관 없다.
        - 예를 들어 앤과 마리는 서로 다른 회사에서 두 번째 계층 기계를 구입할 수 있다. 두 기계가 동일한 plain text에서 동일한 암호 텍스트를 생성하고, 그 반대의 경우도 마찬가지라면 두 기계는 동일한 작업을 수행한다는 것.
		
- 장점/단점
    - 서비스와 구현을 분리할 수 있다. 계층은 하위 계층에서 서비스 set을 받고 상위 계층에 서비스를 제공할 수 있어야 한다.
    - 계층이 어떻게 구현 됐는지는 중요하지 않다. input, output만 맞춰준다면 통신이 가능하다.
    - 통신은 항상 두 개의 엔드 시스템(end-system)만 사용하진 않는다. 모든 계층이 아닌 **일부 계층만 필요한 중간 시스템**도 있다. 프로토콜 계층화를 사용하지 않는다면, 각 중간 시스템을 최종 시스템만큼 복잡하게 만들어야 하므로 전체 시스템 비용이 더 많이 든다.
    → 위 세 개는 프로토콜 레이어의 장점
    
    - 누군가는 하나의 레이어를 두는것이 작업 수행에 좋다고 주장할 수 있다. 따라서 각각의 레이어들이 상위 및 하위 레이어와의 서비스를 주고받는 것은 필요없다고 할 수 있다.  
        -> 이거는 단일 레이어의 장점 : 프로토콜 레이어의 단점  
        
    - 어느날 그들이 코드에 문제가 생김을 인지했을때, 단지 **특정 레이어만 수정**하는 것 대신에 시스템 전부를 수정해야할 것이다.  
        -> 싱글레이어의 단점  


### Logical Connection
- 위 두 가지 원칙을 따르면 다음과 같이 각 레이어 간의 논리적 연결에 대해 생각할 수 있다.
    - 이는 layer-to-layer(레이어 간의 통신)이 이루어지고 있음을 의미한다. 마리와 앤은 각 계층에 헤당 계층에서 생성된 객체를 전송할 수 있는 논리적(가상의) 연결이 있다고 생각할 수 있다.
    - 논리적 연결의 개념은 데이터 통신과 네트워킹에서 발생하는 계층화 작업을 이해하는 것을 도와준다.
    ![[Untitled 2 18.png|Untitled 2 18.png|500]]
    - 하나의 Layer는 하나의 protocol로 구성


### TCP/IP Protocol Suite
- **TCP/IP**는 오늘날 인터넷에서 사용되는 프로토콜 제품군이다. interactive 모듈로 구성된 계층적 프로토콜로, 각 모듈은 특정 기능을 제공한다. 계층적이라는 말은 각 상위계층 프로토콜이 하위 수준 프로토콜에서 제공하는 서비스에 의해 지원된다는 것을 의미합니다.
- 특별한 기능을 수행할 수 있는 프로토콜 → 이걸 쌓아놓은 게 protocol suite
- 계층적으로 구성 : 하위 계층은 상위 계층에게 기능을 제공하고 상위계층은 하위계층의 기능을 가져다 쓴다.
    → 하위 계층에 있는 기능은 상위 계층에 구현할 필요가 없다.
    ![[Untitled 3 17.png|Untitled 3 17.png|500]]

- 계층적 구조
    - 두 호스트 간의 통신에 TCP/IP 프로토콜 suite의 계층이 어떻게 관여하는지 보이기 위해, 각각 link-layer switch가 있는 3개의 LAN(링크)으로 구성된 소규모 인터넷에서 이 suite를 사용한다고 가정한다. 또한 link가 하나의 라우터로 연결되어 있다고 가정한다.
- Communication through an internet
    ![[Untitled 4 15.png|Untitled 4 15.png]]
    - Layering을 사용하면 필요 없는 기능을 빼고 **일부만 사용**해서 쓸 수 있다.
    - LAN끼리 연결해주는 router(중간을 연결시켜줌)의 **Data link와 physical 계층은 두 개로 나누어진다**(이건 바뀔 수 있음). 네트워크 레이어만 같으면 어떤 형태도 연결할 수 있다.
    - 각 계층의 역할을 더 잘 이해하기 위해 우리는 계층 간의 논리적 연결에 대해서 생각해야 한다.

- Description of Each Layer
    - Physical Layer
        - 신호 : physical link
        - 이 계층은 unstructured(구조화 되지 않은), raw, bit-stream data가 **물리적 중간 매체를 통해 송수신 되는 방식을 제어**한다. 이 계층은 네트워크의 전기, 광학 및 물리적 구성 요소로 구성된다. 물리 계층은 모든 상위 계층의 신호를 전달한다.
    - Data Link Layer
        - **한 네트워크(LAN) 안에서의 통신**을 관리
        - datagram을 가져와 link를 통해 이동하는 역할을 담당한다.
        - link는 link-layer switch가 있는 유선 LAN, 무선 LAN, 유선 WAN, 무선 WAN이 될 수 있다.
        - 또한 링크 유형에 따라 다른 프로토콜을 사용할 수도 있다.
        - TCP/IP는 데이터 링크 계층에 대한 특정 프로토콜을 정의하지 않는다. 데이터 링크 계층은 데이터그램을 가져와 프레임이라는 패킷으로 캡슐화한다.
        - 몇몇의 link-layer protocol은 완전한 오류 감지 및 수정 기능을 제공하며, 일부 프로토콜은 오류 수정 기능만 제공한다.
        - 피지컬 레이어 + 데이터 링크 에러 컨트롤. 본인 레이어와 하위 레이어만 관리 가능.
    - Network Layer
        - **한 네트워크에서 다른 네트워크로 넘어가는 걸 관리. 어디로 보내야 할 지(IP address사용)**를 관리한다.
        - source 컴퓨터와 destination 컴퓨터 사이의 연결을 만드는 것을 책임진다. network layer에서의 통신은 host-to-host(호스트간 통신)이다.
        - 그러나, source로부터 destination까지 여러 개의 라우터가 있을 수 있기 때문에 경로에 있는 라우터는 각 패킷에 대해 최적의 경로를 선택할 책임이 있다.
        - 네트워크 계층은 호스트 간 통신을 담당하고 가능한 경로를 통해 패킷을 라우팅한다고 말할 수 있다.
    - Transport Layer
        - **신뢰성 보장**(TCP)
        - transport 계층의 논리적 연결은 **end-to-end**이다.
        - transport 계층에 하나의 프로토콜이 있다. 이는 각 응용 프로그램이 해당 요구 사항에 가장 잘 맞는 프로토콜을 사용할 수 있음을 의미한다.
    - Application Layer
        - 두 application 계층 사이의 논리적 연결은 **end-to-end**이다.
        - application 계층의 통신은 두 개의 **프로세스**(이 계층에서 돌아가는 프로그램) 사이에 있다.
        - 통신을 위해, 프로세스는 다른 프로세스에게 요청을 주고 응답을 받는다.
        - process-to-process 통신은 application 계층의 일이다.
    
    → 계층을 쓰지 않으면 application에서 모든 걸 다 정의해야한다. 하위 계층에 뭐가 있는지 알아야 내가 구현해야 할 서비스를 결정할 수 있다.
    

  
- Encapsulation and Decapsulation
    Internet에서의 protocol 계층화에서 중요한 개념 중 하나는 캡슐화/역캡슐화이다.
    ![[Untitled 5 11.png|Untitled 5 11.png]]
    - 하위 계층으로 내려가면서 각 계층에서 **헤더**를 붙여서 전달.
    - 상위 계층으로 올라가면서 헤더를 하나씩 뗀다.
    - **네트워크 계층(라우터)** : 목적지가 내가 맞으면(자기 주소와 같으면) 헤더 떼고 상위 계층에 주고 내가 아니면 더 좋은 길을 찾아서 보냄.
  
- Addressing
    Internet의 프로토콜 계층화와 관련된 Addressing의 개념
    - 이 모델에서는 한 쌍의 계층간의 논리적 통신이 일어난다.
    - 송신자와 수신자가 관련된 모든 통신에는 **source 주소와 destination 주소**라는 두 개의 주소가 필요하다.
    - physical 계층에서는 주소가 필요하지 않고 물리 계층의 데이터 교환 단위는 bit이다. (주소를 가질 수 없음)
        → 일반적으로 4쌍의 주소가 있다.
        

- **Identical Objects/Addressing** in the TCP/IP Protocol Suite
    각 계층에서 패킷을 뭐라고 부르는지(데이터 교환 단위). 대응하는 계층에서 다루는 메세지의 형태가 똑같아야 한다.
- Pack names / Address
    - Physical layer : bits
    - Data link layer : **frame** / **Link-layer addresses**(**MAC address**)
    - Network : **datagram** / Logical addresses(**IP address**)
    - Transport : **segment** (or user datagram) / **Port numbers**
    - Application :messages / Names
    ![[Untitled 6 11.png|Untitled 6 11.png]]
    참고 : **포트번호는 라우터를 지나면서 바뀔 수 있지만 ip 주소는 바뀌지 않는다.**
    
- Multiplexing and Demultiplexing
    - TCP/IP protocol suite는 일부 계층에서 여러 프로토콜을 사용하기 때문에, source에서는 multiplexing을, destination에서는 demultiplexing을 이용한다고 할 수 있다.
        - 이 경우 multiplexing은 한 계층의 프로토콜이 여러 상위 계층 프로토콜을 캡슐화 할 수 있음을 의미한다.(한 번에 하나씩)
        - demultiplexing은 한 프로토콜이 여러 상위 계층 프로토콜에 패킷을 역캡슐화하여 전달할 수 있음을 의미한다. (한 번에 하나씩)
    ![[Untitled 7 10.png|Untitled 7 10.png]]


### OSI Model
OSI(Open System Interconnection)은 개방형 시스템을 위한 모듈이다. 이것은 서로 다른 두 시스템이 기본(underlying) architecture와 관계 없이 통신할 수 있도록 하는 프로토콜의 집합이다. 기본 하드웨어와 소프트웨어의 로직의 변경 없이 다른 시스템 간의 통신을 용이하게 하는 방법을 보여주기 위한 것이다.
- OSI 7계층 vs. TCP
    ![[Untitled 8 10.png|Untitled 8 10.png]]
    - OSI Model의 **Application + Presentation + Session** 계층 조합이 일반적으로 TCP/IP Protocol Suite의 Application 계층에 대응된다.
  
- Lake of OSI Model’s Success
    - OSI 모델이 TCP/IP protocol suite보다 좋았지만 성공하지 못한 이유
    - OSI 모델은 TCP/IP protocol suite이후에 등장.
        - OSI는 TCP/IP가 완전히 자리 잡았을 때 완성됨. TCP/IP protocol suite에 많은 시간과 비용이 투자 되었기 때문에 이를 변경하려면 많은 비용이 든다.
        - OSI의 일부 계층은 완전히 정의되지 않았다. 예를 들어, presentation 계층과 session 계층에 대한 실제 프로토콜은 완전히 정의되지 않았고 해당 소프트웨어도 완전히 설명되지 않았다.
        - TCP/IP protocol suite를 OSI 모델로 전환하도록 유도할 만큼 높은 수준의 성능은 아니다.